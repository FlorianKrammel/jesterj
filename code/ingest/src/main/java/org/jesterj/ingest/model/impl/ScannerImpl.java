/*
 * Copyright 2014 Needham Software LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jesterj.ingest.model.impl;

import net.jini.space.JavaSpace;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jesterj.ingest.model.Document;
import org.jesterj.ingest.model.Scanner;
import org.jesterj.ingest.model.Step;

import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Function;


/*
 * Created with IntelliJ IDEA.
 * User: gus
 * Date: 11/29/14
 */

/**
 * A base implementation of a scanner that doesn't do anything. {@link #getScanOperation()} and
 * {@link #getLinkDataPersister()} should be overridden.
 */
public abstract class ScannerImpl extends StepImpl implements Scanner {

  private static final Logger log = LogManager.getLogger();

  private long interval;

  // can be used to avoid starting a scan while one is still running. This is not required however
  // and can be ignored if desired.
  protected final AtomicBoolean activeScan = new AtomicBoolean(false);
  
  private final ScheduledExecutorService scheduler =
      Executors.newScheduledThreadPool(1);

  // don't want multiple scans initiated simultaneously. If the scanning mechanism
  // wants to distribute work among threads it may, but that should be done in the scan operation.
  private final ExecutorService scanExec = Executors.newSingleThreadExecutor();

  protected ScannerImpl() {
  }


  /**
   * A function that can be used to provide a custom transformation of the identifier generated by the
   * scanning process. The default transformation is an identity transform.
   *
   * @return the function to map ID to new ID
   */
  protected Function<String, String> getIdFunction() {
    return s -> s;
  }

  /**
   * A procedure that takes an array of Object[] and uses this information to persist a record that this
   * document has been scanned. Typical implementations might be writing a status to cassandra, updating a row in
   * a database, or renaming the target file. By convention, the first element of the object array passed will
   * be a String identifier, and the second argument  will be the document object. Subsequent arguments are
   * unrestricted. The default implementation is a no-op.
   *
   * @return a {@link java.util.function.Consumer} that consumes data about a document and has the side effect of persisting a record that
   * the document was scanned.
   */
  protected Consumer<Object[]> getLinkDataPersister() {
    return objects -> {
    };
  }

  /**
   * A callback that calls docFound() on the scanner when a document is found that needs to be indexed.
   * <p>
   * return a {@link java.lang.Runnable} object that locates documents.
   */
  protected Runnable getScanOperation() {
    return () -> {
    };
  }


  public void run() {
    ScheduledFuture<?> scanner = scheduler.schedule(getScanOperation(), interval, TimeUnit.MILLISECONDS);
    while (this.isActive()) {
      try {
        Thread.sleep(500);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    scanner.cancel(true);
  }

  /**
   * What to do when a document has been recognized as required for indexing.
   *
   * @param doc The document to be processed
   */
  public void docFound(Document doc) {
    doc.put(doc.getIdField(), getIdFunction().apply(doc.getId()));
    getLinkDataPersister().accept(new Object[]{doc.getId(), doc});
    sendToNext(doc);
  }
  
  @Override
  public long getInterval() {
    return this.interval;
  }


  @Override
  public Step getNext(Document d) {
    return null;
  }

  @Override
  public Step[] getSubsequentSteps() {
    return new Step[0];
  }

  @Override
  public boolean isFinalHelper() {
    return false;
  }

  @Override
  public synchronized void activate() {
  }

  @Override
  public synchronized void deactivate() {
  }

  @Override
  public boolean isActive() {
    return false;
  }

  @Override
  public boolean add(Document document) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean offer(Document document) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document remove() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document poll() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document element() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document peek() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public void put(Document document) throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean offer(Document document, long timeout, TimeUnit unit) throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document take() throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document poll(long timeout, TimeUnit unit) throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public int remainingCapacity() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean remove(Object o) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean containsAll(Collection<?> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean addAll(Collection<? extends Document> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean removeAll(Collection<?> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean retainAll(Collection<?> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public void clear() {

  }

  @Override
  public int size() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean isEmpty() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean contains(Object o) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Iterator<Document> iterator() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Object[] toArray() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public <T> T[] toArray(T[] a) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public int drainTo(Collection<? super Document> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public int drainTo(Collection<? super Document> c, int maxElements) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public void advertise() {
    // ignore for now
  }

  @Override
  public void stopAdvertising() {
    // ignore for now
  }

  @Override
  public void acceptJiniRequests() {
    // ignore for now
  }

  @Override
  public void denyJiniRequests() {
    // ignore for now
  }

  @Override
  public boolean readyForJiniRequests() {
    return false;
  }


  @Override
  protected Logger getLogger() {
    return log;
  }

  public boolean isActiveScan() {
    return activeScan.get();
  }

  public void scanStarted() {
    activeScan.set(true);
  }

  public void scanFinished() {
    activeScan.set(false);
  }

  public static abstract class Builder extends StepImpl.Builder {

    private ScannerImpl obj;

    public Builder() {

    }
    
    private Class whoAmI() {
      return new Object(){}.getClass().getEnclosingMethod().getDeclaringClass();
    }

    @Override
    public StepImpl.Builder batchSize(int size) {
      super.batchSize(size);
      return this;
    }

    @Override
    public StepImpl.Builder nextStep(Step next) {
      super.nextStep(next);
      return this;
    }

    @Override
    public StepImpl.Builder outputSpace(JavaSpace outputSpace) {
      super.outputSpace(outputSpace);
      return this;
    }

    @Override
    public StepImpl.Builder inputSpace(JavaSpace inputSpace) {
      super.inputSpace(inputSpace);
      return this;
    }

    @Override
    public StepImpl.Builder stepName(String stepName) {
      super.stepName(stepName);
      return this;
    }
    @Override
    protected ScannerImpl getObject() {
      return obj;
    }
    private void setObj(ScannerImpl obj) {
      this.obj = obj;
    }

    public Builder interval(long interval) {
      getObject().interval = interval;
      return this;
    }

    public abstract ScannerImpl build();


  }


}
