/*
 * Copyright 2014 Needham Software LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jesterj.ingest.model.impl;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jesterj.ingest.model.Document;
import org.jesterj.ingest.model.Scanner;
import org.jesterj.ingest.model.Step;

import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Function;


/*
 * Created with IntelliJ IDEA.
 * User: gus
 * Date: 11/29/14
 */
public class ScannerImpl extends StepImpl implements Scanner {

  private static final Logger log = LogManager.getLogger();

  private long interval;
  private volatile boolean active;
  private final ScheduledExecutorService scheduler =
      Executors.newScheduledThreadPool(1);

  public ScannerImpl(Builder builder) {
    super(builder);
    this.interval = builder.interval;

  }


  /**
   * A function that can be used to provide a custom transformation of the identifier generated by the
   * scanning process. The default transformation is an identity transform.
   *
   * @return the function to map ID to new ID
   */
  protected Function<String, String> getIdFunction() {
    return s -> s;
  }

  /**
   * A procedure that takes an array of Object[] and uses this information to persist a record that this
   * document has been scanned. Typical implimemtations might be writing a status to cassandra, updating a row in
   * a database, or renaming the target file. By convention, the first element of the object array passed will
   * be a String identifer, and the second argument  will be the document object. Subsequent arguments are
   * unrestricted. The default implementation is a no-op.
   *
   * @return a {@link java.util.function.Consumer} that consumes data about a document and has the side effect of persisting a record that
   * the document was scanned.
   */
  protected Consumer<Object[]> getLinkDataPersister() {
    return objects -> {
    };
  }

  /**
   * A procedure that when invoked produces an array of document objects.
   * <p>
   * return a {@link java.util.concurrent.Callable} object that generates documents.
   */
  Callable<Document[]> getScanOperation() {
    return () -> new Document[0];
  }


  public void run() {
    ScheduledFuture<?> scanner = scheduler.schedule(() -> {
      try {
        Document[] docs = getScanOperation().call();
        for (Document doc : docs) {
          doc.put(doc.getIdField(), getIdFunction().apply(doc.getId()));
          getLinkDataPersister().accept(new Object[]{doc.getId(), doc});
          sendToNext(doc);
        }
      } catch (Exception e) {
        // We don't generally want to let the exception escape, since that will 
        // halt future executions.
        log.error(e);
      }
    }, interval, TimeUnit.MILLISECONDS);

    while (this.active) {
      try {
        Thread.sleep(500);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    scanner.cancel(true);
  }


  @Override
  public long getInterval() {
    return this.interval;
  }


  @Override
  public Step getNext(Document d) {
    return null;
  }

  @Override
  public Step[] getSubsequentSteps() {
    return new Step[0];
  }

  @Override
  public boolean isFinalHelper() {
    return false;
  }

  @Override
  public synchronized void activate() {
  }

  @Override
  public synchronized void deactivate() {
  }

  @Override
  public boolean isActive() {
    return false;
  }

  @Override
  public boolean add(Document document) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean offer(Document document) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document remove() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document poll() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document element() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document peek() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public void put(Document document) throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean offer(Document document, long timeout, TimeUnit unit) throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document take() throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Document poll(long timeout, TimeUnit unit) throws InterruptedException {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public int remainingCapacity() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean remove(Object o) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean containsAll(Collection<?> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean addAll(Collection<? extends Document> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean removeAll(Collection<?> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean retainAll(Collection<?> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public void clear() {

  }

  @Override
  public int size() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean isEmpty() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public boolean contains(Object o) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Iterator<Document> iterator() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public Object[] toArray() {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public <T> T[] toArray(T[] a) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public int drainTo(Collection<? super Document> c) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public int drainTo(Collection<? super Document> c, int maxElements) {
    throw new UnsupportedOperationException("Scanners are a push only source of documents. Queue mthods are not supported for this type of step.");
  }

  @Override
  public void advertise() {
    // ignore for now
  }

  @Override
  public void stopAdvertising() {
    // ignore for now
  }

  @Override
  public void acceptJiniRequests() {
    // ignore for now
  }

  @Override
  public void denyJiniRequests() {
    // ignore for now
  }

  @Override
  public boolean readyForJiniRequests() {
    return false;
  }


  @Override
  protected Logger getLogger() {
    return log;
  }


  public static Builder builder() {
    return new BuildMe();
  }

  public static abstract class Builder<T extends Builder<T>> extends StepImpl.Builder<T> {

    private long interval;

    public Builder interval(long interval) {
      this.interval = interval;
      return this;
    }

    public ScannerImpl build() {
      return new ScannerImpl(this);
    }

    public abstract T self();
  }

  public static class BuildMe extends Builder<BuildMe> {

    @Override
    public BuildMe self() {
      return this;
    }
  }

}
